# -*- coding: utf-8 -*-
"""22-Estatistica-Descritiva-Univariada-Quantitativa-parte2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1dkCYqvRS8ZqEyPga6TbGUYNKIS5Mkqu0

# <font color='blue'>Estatística Descritiva Univariada quantitativa - parte 2</font>
"""

# Versão da Linguagem Python
from platform import python_version
print('Versão da Linguagem Python Usada Neste Jupyter Notebook:', python_version())

# Verificando as versões dos pacotes instalados
pandasVersion = !pip show Pandas
print('Pandas', pandasVersion[1])

"""### Medidas de dispersão ou variabilidade
<details>
    <summary>
        <a class="btnfire small stroke"><em class="fas fa-chevron-circle-down"></em>&nbsp;&nbsp;Clique para mais detalhes</a>
    </summary>
    <br>

As **medidas de dispersão**, também conhecidas como medidas de variabilidade, são utilizadas para caracterizar a dispersão ou variabilidade dos dados. Essas medidas nos ajudam a compreender o quão longe os dados se encontram em relação à média. <br>
As medidas de dispersão mais comuns referem-se: <br>
- Amplitude; <br>
- Desvio-médio; <br>
- Variância; <br>
- Desvio-padrão; <br>
- Erro-padrão; <br>
- Coeficiente de variação.

</details>

### Amplitude
A amplitude representa a diferença entre o maior e o menor valor do conjunto de observações;
"""

# Importando os pacotes
import pandas as pd
import numpy as np

# Criando um array
array = np.arange(5, 30, 5)
array

# Calculando a amplitude
amplitude = max(array) - min(array)
amplitude

"""### Desvio-médio
O **desvio-médio** representa a média aritmética dos desvios absolutos. Sendo que o desvio absoluto é o módulo da diferença entre cada valor observado e a média da variável. <br>
Quanto maior o desvio-médio, maior a dispersão dos dados.
"""

# Criando uma lista
lista = [12.4, 22.6, 18.9, 9.7, 14.5, 22.5, 26.3, 17.7, 31.2, 20.4]
lista

# Calculando a média
media = np.mean(lista)
media

# Criando uma lista vazia
listaDesviosAbsolutos = []

# Calculando os desvios absolutos
for i in lista:
    diferenca = i - media
    listaDesviosAbsolutos.append(np.absolute(diferenca))
else:
    print(listaDesviosAbsolutos)

# Calculando a média dos desvios absolutos para encontrar o desvio-médio
np.mean(listaDesviosAbsolutos)

# Calculando o desvio-médio
desvioMedio = np.mean(np.absolute(lista - np.mean(lista)))
desvioMedio

# Criando um dicionário
dicionario = {
    "Número de gols": [0, 1, 2, 3, 4, 5, 6],
    "Fi": [5, 8, 6, 4, 4, 2, 1]
}
df = pd.DataFrame(dicionario)
df

# Calculando o desvio-médio considerando a frequência absoluta dos dados, tomando como base a média ponderada
desvioMedio = np.average(np.absolute(df["Número de gols"] - np.average(df["Número de gols"], weights=df.Fi)), weights=df.Fi)
desvioMedio

"""### Variância
A variância é uma medida de dispersão que avalia o quanto os dados estão dispersos em relação à média. <br>
Quanto maior a variância, maior a dispersão dos dados. <br>
Em vez de considerar a média dos desvios absolutos, conforme calculamos no desvio médio, a variância é calculada a partir da média dos desvios quadrados.  
"""

# Imprimindo a lista
lista

# Criando uma lista vazia
listaDesviosQuadrados = []

# Calculando os desvios quadrados
for i in lista:
    diferenca = i - media
    listaDesviosQuadrados.append(np.power(diferenca,2))
else:
    print(listaDesviosQuadrados)

# Calculando a média dos desvios quadrados para encontrar a variância da população
np.mean(listaDesviosQuadrados)

# Variância da amostra
np.sum(listaDesviosQuadrados) / (np.size(lista) - 1)

# Variância da população
np.var(lista)

# Variância da amostra
np.var(lista, ddof=1)

# Visualizando o DataFrame
df

# Calculando a variância da população considerando a frequência absoluta dos dados, tomando como base a média ponderada
variancia = np.average(np.power(df["Número de gols"] - np.average(df["Número de gols"], weights=df.Fi), 2), weights=df.Fi)
variancia

"""### Desvio-padrão
Como a variância considera a média dos desvios quadrados, seu valor tende a ser muito grande e de difícil interpretação. Para resolver esse problema, nós extraímos a raiz quadrada da variância e encontramos o desvio padrão. Sendo assim, o desvio padrão é a raiz quadrada da variância. <br>
O desvio-padrão é expresso na unidade dos dados com os quais estamos trabalhando e é a medida de dispersão utilizada com maior frequência.
"""

# Imprimindo a lista
lista

# Desvio-padrão da população
np.std(lista)

# Desvio-padrão da amostra
np.std(lista, ddof=1)

"""### Erro-padrão
O erro-padrão é o desvio-padrão da média. É obtido dividindo-se o desvio-padrão pela raiz quadrada do tamanho da população ou amostra. <br>
O erro-padrão é uma medida que ajuda a avaliar a confiabilidade da média calculada.
"""

# Tempo de preparo, em segundos, do concreto em uma betoneira
lista2 = [124, 111, 132, 142, 108, 127, 133, 144, 148, 105]
lista2

# Calculando o erro-padrão da população
erroPadrao = np.std(lista2) / np.sqrt(np.size(lista2))
erroPadrao

# Calculando o erro-padrão da amostra
erroPadrao = np.std(lista2, ddof=1) / np.sqrt(np.size(lista2))
erroPadrao

lista3 = [125, 102, 135, 126, 132, 129, 156, 112, 108, 134, 126, 104, 143, 140, 138, 129, 119, 114, 107, 121, 124, 112, 148, 145, 130, 125, 120, 127, 106, 148]
lista3

# Calculando o erro padrão da população
erroPadrao = np.std(lista3) / np.sqrt(np.size(lista3))
erroPadrao

"""### Coeficiente de variação
O coeficiente de variação é uma medida de dispersão relativa que fornece a variação dos dados em relação à média. Quanto menor for o seu valor, mais homogêneos serão os dados, ou seja, menor será a variabilidade em torno da média. <br>
Um coeficiente de variação pode ser considerado baixo, indicando um conjunto de dados razoavelmente homogêneo, quando for menor do que 30%. Por outro lado, se esse valor for acima de 30% o conjunto de dados pode ser considerado heterogêneo. <br>
O coeficiente de variação é calculado dividindo-se o desvio padrão pela média dos elementos. E por ser um percentual, o resultado da divisão deve ser multiplicado por cem.
"""

# Coeficiente de variação da população
cvp = (np.std(lista3) / np.mean(lista3)) * 100
cvp

# Coeficiente de variação da amostra
cva = (np.std(lista3, ddof=1) / np.mean(lista3)) * 100
cva

"""### Comparando performance do NumPy versus SciPy"""

# Importando pacote para calcular o tempo de execução de uma célula
from datetime import datetime
import scipy.stats as stat

# Criando um array gigante
array = np.arange(1, 999999999, 1)

# Marca o início da execução do cálculo do erro padrão da população com o SciPy.
inicio = datetime.now()

# Calcula o erro padrão da população com o SciPy
erroPadraoSciPy = stat.sem(array, ddof=0)

# Calcula o tempo decorrido
tempoSciPy = datetime.now() - inicio

# Imprime o tempo total
print('Tempo Total SciPy:', tempoSciPy)
print("Erro padrão: ", erroPadraoSciPy)

# Marca o início da execução do cálculo do erro padrão da população com o NumPy.
inicio = datetime.now()

# Calcula o erro padrão da população com o NumPy
erroPadraoNumPy = np.std(array) / np.sqrt(np.size(array))

# Calcula o tempo decorrido
tempoNumPy = datetime.now() - inicio

# Imprime o tempo total
print('Tempo Total NumPy:', tempoNumPy)
print("Erro padrão: ", erroPadraoNumPy)

print("O NumPy foi", tempoSciPy - tempoNumPy, "segundos mais rápido que o SciPy neste exemplo.")

